## 1.6存储设备形成层次结构

![](D:\00000\computer system\picture\QQ图片20200306111253.png)

从上到下越来越慢，容量越来越大，造价越来越便宜

## 1.7操作系统管理硬件

所有应用程序对硬件的操作尝试都必须经过操作系统

![](D:\00000\computer system\picture\QQ图片20200310083952.png)

* 操作系统的两个基本功能
  1. 防止硬件被失控的应用程序滥用
  2. 向应用程序提供简单一致的机制来控制复杂而又通常大不同的低级硬件设备

通过抽象概念（进程，虚拟内存和文件）拉实现这两个功能

![](D:\00000\computer system\picture\QQ图片20200310084232.png)

文件是对I/O设备的抽象表示，虚拟内存是对主存和硬盘I/O设备的抽象表示，进程则是对处理器，主存和I/O设备的抽象表示

### 1.7.1进程

在一个系统上可以同时运行多个进程，每个进程都像是在独占硬件

并发运行：一个进程的指令和另一个进程的指令是交错执行的

大多数系统中需要运行的进程数是多于CPU数的

操作系统实现这种交错执行的机制称为**上下文切换**

操作系统保持追踪进程运行所需的所有状态信息

上下文：包含很多信息，比如包括PC和寄存器文件的当前值，以及主存内容

因为单处理器系统都只能执行一个进程代码，当操作系统决定把控制权从当前进程转移到某个新进程是就会进行上下文切换，即保存当前上下文，恢复新进程上下文，然后将控制权传递到新进程

例：有两个并发进程hello和shell，最开始只有shell在运行，输入命令之后，即当我们要求他运行hello程序的时候，shell通过调用一个专门的函数，即系统调用来执行我们的请求系统调用会将控制权传给操作系统，操作系统保存shell的上下文，创建一个新的hello的进程及上下文，hello结束后，操作系统恢复shell的上下文并把控制权还给shell。

从一个进程到另一个进程的准换是由操作系统内核管理的

内核：操作系统代码常驻主存的部分。在应用程序需要操作系统进行操作的时候，他执行一条特殊的系统调用指令，将控制权传给内核，之后内核执行被请求的操作并返回应用程序。

**注：内核不是一个独立的进程，相反他是系统管理全部进程所用代码和数据结构的集合**

![](D:\00000\computer system\picture\QQ图片20200310091348.png)

### 1.7.2线程

在现代操作系统中，进程实际上可以由多个线程的执行单元组成，每个线程都存在与进程的上下文中，并共享同样的代码和全局数据

在有多个处理器的时候，多线程是一种让程序可以运行的更快地方法

### 1.7.3虚拟内存

给每一个进程提供一个在独占的使用主存的假象

每个假象看到的内存都是一致的，被称为虚拟地址空间

linux中最上面是给操作系统中的代码合数据的，底部存放用户自定义的代码和数据

![image-20200310164339607](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200310164339607.png)

从下往上地址增大

* 程序代码和数据

  对所有进程来说，代码是从同一个固定的地址开始的，紧接着是C全局变量相对应的数据位置，代码和数据区是直接按照可执行目标文件的内容初始化的

* 堆

  代码和数据区后紧随这的就是堆，代码和数据一开始就被指定了大小，与此不同当调用malloc和free这样的函数时，堆可以在运行时动态的扩展和收缩

* 共享库

  大约在地址空间中间部分是一块用来放c标准库和数学库这样的共享库的代码和数据的区域，功能强大，很难懂

* 栈

  位于用户虚拟地址空间顶部的是用户栈，编译器靠他来实现函数的调用，在程序执行期间也能动态的扩展和收缩，每调用一个函数，栈就会增长，每当一个函数返回，栈就会收缩

* 内核虚拟内存

  空间地址顶部是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数，相反，必须调用内核来着行这些操作

基本思想：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存

### 1.7.4文件

文件就是字节序列

每个I/O设备都可以看成一个文件，系统中所有的输入输出都是通过使用一小组被称为Unix I/O的系统函数调用读写文件来实现的。

给应用程序一个统一的视图，程序员不用了解具体的磁盘技术也能处理磁盘文件的应用，即同一个程序可以在使用不同磁盘技术的不同操作系统上运行

